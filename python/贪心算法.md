## 概念：
局部最优 --实现-- 全局最优
1. 将问题分解为若干个子问题
2. 找出适合的贪心策略
3. 求解每一个子问题的最优解
4. 将局部最优解堆叠成全局最优解  

## 455.分发饼干（https://leetcode.com/problems/assign-cookies/description/）
局部最优就是大饼干喂给胃口大的,充分利用饼干尺寸喂饱一个  
全局最优就是喂饱尽可能多的小孩。  
1. 先将饼干数组和小孩数组排序
2. 从后向前遍历小孩数组，用大饼干优先满足胃口大的，并统计满足小孩数量。
```python
class Solution:
    def findContentChildren(self, g, s):
        g.sort()  # 将孩子的贪心因子排序
        s.sort()  # 将饼干的尺寸排序
        index = len(s) - 1  # 饼干数组的下标，从最后一个饼干开始
        result = 0  # 满足孩子的数量
        for i in range(len(g)-1, -1, -1):  # 遍历胃口，从最后一个孩子开始
            if index >= 0 and s[index] >= g[i]:  # 遍历饼干
                result += 1
                index -= 1
        return result
```

## 376. 摆动序列 (https://leetcode.com/problems/wiggle-subsequence/description/)
[1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3)  是正负交替出现的.  
给定一个整数序列，返回作为摆动序列的最长子序列的长度。从原始序列中删除一些（也可以不删除）元素来获得子序列

*记录峰值* -》 返回峰值总数  
只需要在 这个坡度 摆动变化的时候，更新 prediff 就行，这样 prediff 在 单调区间有平坡的时候 就不会发生变化，造成我们的误判。
```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        if len(nums) <= 1:
            return len(nums)
        currDiff = 0
        preDiff = 0
        res = 1 #default last element is peek
        for i in range(len(nums) - 1):
            currDiff = nums[i+1] - nums[i]
            if (preDiff >= 0 and currDiff < 0) or (preDiff <= 0 and currDiff > 0):
                res += 1
                preDiff = currDiff #update preDiff when update result
        return res
```

*approach 2*: dp 记录最大摆动长度  
对于我们当前考虑的这个数，要么是作为山峰（即 `nums[i] > nums[i-1]）`，要么是作为山谷（即 `nums[i] < nums[i - 1]）`。

设 dp 状态dp[i][0]，表示考虑前 i 个数，第 i 个数作为山峰的摆动子序列的最长长度
设 dp 状态dp[i][1]，表示考虑前 i 个数，第 i 个数作为山谷的摆动子序列的最长长度
则转移方程为：

`dp[i][0] = max(dp[i][0], dp[j][1] + 1)`，其中0 < j < i且nums[j] < nums[i]，表示将 nums[i]接到前面某个山谷后面，作为山峰。
`dp[i][1] = max(dp[i][1], dp[j][0] + 1)`，其中0 < j < i且nums[j] > nums[i]，表示将 nums[i]接到前面某个山峰后面，作为山谷。
```python
class Solution:
    def wiggleMaxLength(self, nums):
        dp = [[0, 0] for _ in range(len(nums))]  # 创建二维dp数组，用于记录摆动序列的最大长度
        dp[0][0] = dp[0][1] = 1  # 初始条件，序列中的第一个元素默认为峰值，最小长度为1
        for i in range(1, len(nums)):
            dp[i][0] = dp[i][1] = 1  # 初始化当前位置的dp值为1
            for j in range(i):
                if nums[j] > nums[i]:
                    dp[i][1] = max(dp[i][1], dp[j][0] + 1)  # 如果前一个数比当前数大，可以形成一个上升峰值，更新dp[i][1]
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i][0] = max(dp[i][0], dp[j][1] + 1)  # 如果前一个数比当前数小，可以形成一个下降峰值，更新dp[i][0]
        return max(dp[-1][0], dp[-1][1])  # 返回最大的摆动序列长度
```

## 53.最大子序和 (https://leetcode.com/problems/maximum-subarray/description/)
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和  
局部最优的情况下，并记录最大的“连续和”，可以推出全局最优。
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res = -float('inf')
        sum_ = 0
        for i in range(len(nums)):
            sum_ += nums[i]
            res = max(sum_, res)
            if sum_ < 0:
                sum_ = 0
        return res
```